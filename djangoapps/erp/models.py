import uuid
from functools import reduce

import pytz
from django.conf import settings
from django.conf.global_settings import LANGUAGES
from django.contrib.auth.models import User
from django.db import models
from django.utils import timezone
from djmoney.models.fields import MoneyField, CurrencyField
from djmoney.money import Money
from natural_keys import NaturalKeyModel

from djangoapps.erp.enums import TextChoices
from djangoapps.erp.signals import state_changed


class ByCodeManager(models.Manager):
    def get_by_natural_key(self, code):
        return self.get(code=code)


class CodeNaturalKeyAbstractModel(models.Model):
    code = models.CharField(max_length=200, unique=True)

    objects = ByCodeManager()

    class Meta:
        abstract = True

    def natural_key(self):
        return (self.code,)


class StateMixin(models.Model):
    """Triggers state signal on update of state. Derives should redefine state field."""

    state = models.CharField(max_length=200, null=True, blank=True)

    def set_state(self, new_state):
        """Besides saving state it notifies all interested partners about it."""
        self.state = new_state
        self.save()

    def _notify_state_change(self, old_state):
        # send signal
        state_changed.send(sender=self.__class__, old_state=old_state, instance=self)

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        old = self.__class__.objects.filter(pk=self.pk).first()
        old_state = old.state if old else None

        super().save(force_insert, force_update, using, update_fields)

        if old_state != self.state:
            self._notify_state_change(old_state=old_state)

    class Meta:
        abstract = True


class Document(StateMixin):
    """
    Represents any document. Track created/updated, support state.
    Each document have unique number generated by template.

    Usually subclass redefine state field with own State choices.
    """
    class State(TextChoices):
        DRAFT = 'DRAFT', "Черновик"
        FINAL = 'FINAL', "Окончательный"

    DOCUMENT_NUMBER_TEMPLATE = 'D-{number_total}'

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)
    document_number = models.CharField(max_length=200, blank=True, null=True)
    document_date = models.DateField(blank=True, null=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    created_at = models.DateTimeField(auto_now_add=True, null=True, editable=False)
    updated_at = models.DateTimeField(auto_now=True, null=True, editable=False)

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        is_create = self.pk is None

        if is_create and not self.document_number:
            self.document_number = self._generate_document_number()

        super().save(force_insert, force_update, using, update_fields)

    def _generate_document_number(self):
        template = self.DOCUMENT_NUMBER_TEMPLATE
        if not self.document_date:
            self.document_date = timezone.now().date()
        today_start = self.document_date
        month_start = today_start.replace(day=1)
        year_start = month_start.replace(month=1)
        number = template.format(
            number_today=self.__class__.objects.filter(document_date__gte=today_start).count() + 1,
            number_month=self.__class__.objects.filter(document_date__gte=month_start).count() + 1,
            number_year=self.__class__.objects.filter(document_date__gte=year_start).count() + 1,
            number_total=self.__class__.objects.all().count() + 1,
        )
        return number

    def __str__(self):
        return f'{self.document_number} at {self.document_date}'

    class Meta:
        abstract = True


class Person(NaturalKeyModel):
    code = models.SlugField(max_length=100, default=uuid.uuid4, unique=True)
    first_name = models.CharField(max_length=100, blank=True)
    last_name = models.CharField(max_length=150, blank=True)
    email = models.EmailField(null=True, unique=True)  # TODO: can we use unique=True for nullable ?
    phone = models.CharField(max_length=20, default='', blank=True)
    skype = models.CharField(max_length=100, default='', blank=True)
    google_account = models.CharField(max_length=200, default='', blank=True)
    github_account = models.CharField(max_length=200, default='', blank=True)
    avatar_url = models.URLField(null=True, blank=True)
    language = models.CharField(max_length=10, choices=LANGUAGES, default='ru')
    country = models.CharField(max_length=100, default='', blank=True)
    city = models.CharField(max_length=100, default='', blank=True)
    timezone = models.CharField(max_length=100, choices=[(tz, tz) for tz in pytz.all_timezones],
                                default=settings.TIME_ZONE)
    user = models.OneToOneField(User, null=True, on_delete=models.SET_NULL)
    is_admin = models.BooleanField(default=False)
    can_teach = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True, null=True, editable=False)
    updated_at = models.DateTimeField(auto_now=True, null=True, editable=False)

    @property
    def full_name(self):
        # filter out empty names
        names = [name for name in (self.first_name, self.last_name) if name]
        return ' '.join(names)

    @classmethod
    def _guess_first_and_last_name(cls, name: str):
        names = iter(name.split(maxsplit=1) if name else [])
        first_name = next(names, '')
        last_name = next(names, '')
        return first_name.strip(), last_name.strip()

    @full_name.setter
    def full_name(self, value):
        self.first_name, self.last_name = self._guess_first_and_last_name(value)


    def __str__(self):
        return f'{self.full_name} {self.email}'

    @classmethod
    def lookup_by_email(cls, email):
        return cls.objects.filter(email__iexact=email).first()


class Product(CodeNaturalKeyAbstractModel):
    class State(TextChoices):
        DRAFT = 'DRAFT', 'Черновик'
        ACTIVE = 'ACTIVE', 'Активен'
        ARCHIVED = 'ARCHIVED', 'Архивирован'

    price = MoneyField(max_digits=14, decimal_places=2)
    name = models.CharField(max_length=250)
    state = models.CharField(max_length=8, choices=State.choices, null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True, null=True, editable=False)
    updated_at = models.DateTimeField(auto_now=True, null=True, editable=False)


class ClientOrder(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'CO-{number_month}'

    class State(TextChoices):
        NEW = 'NEW', "Новый"
        WAITING = 'WAITING', "Ожидает"
        CONFIRMED = 'CONFIRMED', "Подтверждён"
        COMPLETED = 'COMPLETED', "Выполнен"
        PROCESSING = 'PROCESSING', "Исполняется"
        CANCELLED = 'CANCELLED', "Отменён"

    class FulfillOn(TextChoices):
        CREATED = 'CREATED', "когда создан"
        CONFIRMED = 'CONFIRMED', "когда подтверждён"
        ORDER_PAYED_FULL = 'ORDER_PAYED_FULL', "когда счет оплачен полностью"
        ORDER_PAYED_PARTLY = 'ORDER_PAYED_PARTLY', "когда счет оплачен частично"

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)
    client = models.ForeignKey(Person, on_delete=models.CASCADE, null=True, blank=True)
    currency = CurrencyField()
    valid_until = models.DateField(null=True, blank=True)

    comment = models.TextField(null=True, blank=True)
    fulfill_on = models.CharField(max_length=200, choices=FulfillOn.choices, null=True, blank=True)

    @property
    def amount(self):
        currency = self.currency
        if not currency:
            raise ValueError(f'No currency in order {self}')
        return reduce(lambda x, item: x + item.sum, self.items.all(), Money(0, currency))

    def add_item(self, product: Product, quantity: int = 1):
        ClientOrderItem.objects.create(
            product=product,
            client_order=self,
            price=product.price,
            quantity=quantity
        )

    def create_invoice(self) -> 'Invoice':
        return Invoice(
            client_order=self,
            amount=self.amount,
            client=self.client,
        )

    def fulfill(self):
        states = ClientOrder.State
        assert self.state in (states.NEW, states.CONFIRMED), f"Cannot fulfill from state {self.state}"
        self.set_state(states.PROCESSING)


class ClientOrderItem(models.Model):
    product = models.ForeignKey(Product, on_delete=models.SET_NULL, null=True)
    client_order = models.ForeignKey(ClientOrder, on_delete=models.CASCADE, related_name='items')
    price = MoneyField(max_digits=14, decimal_places=2)
    quantity = models.IntegerField(default=1)

    @property
    def sum(self):
        return self.price * self.quantity


class Invoice(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'I-{number_month}'

    class State(TextChoices):
        NEW = 'NEW', 'Новый'
        WAITING = 'WAITING', 'Ожидает'
        PAYED_PARTLY = 'PAYED_PARTLY', 'Частично оплачен'
        PAYED_FULLY = 'PAYED_FULLY', 'Полностью оплачен'
        CANCELLED = 'CANCELLED', 'Отменен'

    client = models.ForeignKey(Person, on_delete=models.CASCADE, null=True, blank=True)
    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)

    client_order = models.ForeignKey(ClientOrder, on_delete=models.PROTECT, null=True, blank=True)
    valid_until = models.DateField(null=True, blank=True)
    amount = MoneyField(max_digits=14, decimal_places=2)

    @property
    def payed_amount(self):
        return reduce(
            lambda x, payment: x + payment.amount,
            self.paymentin_set.filter(state=PaymentIn.State.PROCESSED),
            Money(0, self.amount.currency))

    @property
    def is_payed(self):
        return self.payed_amount >= self.amount

    def create_payment(self) -> 'PaymentIn':
        if self.document_number and self.document_date:
            description = f"Оплата по счёту \"{self.document_number}\" от {self.document_date.strftime('%d.%m.%Y')}"
        else:
            description = ''
        return PaymentIn(
            invoice=self,
            amount=self.amount,
            payer=self.client,
            description=description
        )


class PaymentIn(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'PI-{number_year}'

    class State(TextChoices):
        NEW = 'NEW', 'Новый'
        WAITING = 'WAITING', 'Ожидает оплаты'
        PROCESSED = 'PROCESSED', 'Получен'
        CANCELLED = 'CANCELLED', 'Отменен'

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)

    payer = models.ForeignKey(Person, on_delete=models.PROTECT, null=True, blank=True)
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE, null=True, blank=True)
    amount = MoneyField(max_digits=14, decimal_places=2)
    description = models.CharField(max_length=255, null=True, blank=True)

    payment_gateway = models.CharField(max_length=255, null=True, blank=True, help_text="Payment gateway")
    gateway_payment_id = models.CharField(max_length=255, null=True, blank=True, help_text="Payment ID in the gateway")
    gateway_payment_url = models.URLField(null=True, blank=True, help_text="URL to pay this payment")
    completed_at = models.DateTimeField(null=True, blank=True)

    def is_completed(self):
        return self.state == self.State.PROCESSED

    def __str__(self):
        return f'#{self.id} {self.amount} ({self.state})'


class ShipmentItem(models.Model):
    shipment = models.ForeignKey('Shipment', on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.IntegerField(default=1)


class Shipment(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'S-{number_year}'

    receiver = models.ForeignKey(Person, on_delete=models.PROTECT)
    order = models.ForeignKey(ClientOrder, on_delete=models.CASCADE, null=True, blank=True)
    items = models.ManyToManyField(Product, through=ShipmentItem)
    description = models.CharField(max_length=255, null=True, blank=True)

    def add_item(self, product: Product, quantity: int):
        item = ShipmentItem(product=product, shipment=self, quantity=quantity)
        item.save()
        self.shipmentitem_set.add(item)

    @staticmethod
    def from_order(order: ClientOrder):
        shipment = Shipment(order=order, receiver=order.client)
        for item in order.items.all():
            shipment.add_item(item.product, item.quantity)
        return shipment
