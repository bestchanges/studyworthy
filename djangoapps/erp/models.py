import uuid
from functools import reduce

import pytz
from django.conf import settings
from django.contrib.auth.models import User
from django.db import models
from django.utils import timezone
from django.utils.translation import ugettext_lazy as _
from djmoney.models.fields import MoneyField, CurrencyField
from djmoney.money import Money

from djangoapps.erp.enums import TextChoices
from djangoapps.erp.signals import state_changed


class OrderingMixin(models.Model):
    ordering = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ['ordering']
        abstract = True


class ByCodeManager(models.Manager):
    def get_by_natural_key(self, code):
        return self.get(code=code)


class CodeNaturalKeyAbstractModel(models.Model):
    code = models.SlugField(max_length=200, default=uuid.uuid4, unique=True, verbose_name=_('Code'))

    objects = ByCodeManager()

    class Meta:
        abstract = True

    def natural_key(self):
        return (self.code,)


class CreatedUpdatedMixin(models.Model):
    created_at = models.DateTimeField(auto_now_add=True, null=True, editable=False)
    updated_at = models.DateTimeField(auto_now=True, null=True, editable=False)

    class Meta:
        abstract = True


class StatefulMixin(models.Model):
    """Triggers state signal on update of state. Derives should redefine state field."""

    state = models.CharField(max_length=200, null=True, blank=True)

    def set_state(self, new_state):
        """Besides saving state it notifies all interested partners about it."""
        self.state = new_state
        self.save()

    def _notify_state_change(self, old_state):
        # send signal
        state_changed.send(sender=self.__class__, old_state=old_state, instance=self)

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        old = self.__class__.objects.filter(pk=self.pk).first()
        old_state = old.state if old else None

        super().save(force_insert, force_update, using, update_fields)

        if old_state != self.state:
            self._notify_state_change(old_state=old_state)

    class Meta:
        abstract = True


class Document(CreatedUpdatedMixin, StatefulMixin):
    """
    Represents any document. Track created/updated, support state.
    Each document have unique number generated by template.

    Usually subclass redefine state field with own State choices.
    """
    class State(TextChoices):
        DRAFT = 'DRAFT', "Черновик"
        FINAL = 'FINAL', "Окончательный"

    DOCUMENT_NUMBER_TEMPLATE = 'D-{number_total}'

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)
    document_number = models.CharField(max_length=200, blank=True, null=True)
    document_date = models.DateField(blank=True, null=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        is_create = self.pk is None

        if is_create and not self.document_number:
            self.document_number = self._generate_document_number()

        super().save(force_insert, force_update, using, update_fields)

    def _generate_document_number(self):
        template = self.DOCUMENT_NUMBER_TEMPLATE
        if not self.document_date:
            self.document_date = timezone.now().date()
        today_start = self.document_date
        month_start = today_start.replace(day=1)
        year_start = month_start.replace(month=1)
        number = template.format(
            number_today=self.__class__.objects.filter(document_date__gte=today_start).count() + 1,
            number_month=self.__class__.objects.filter(document_date__gte=month_start).count() + 1,
            number_year=self.__class__.objects.filter(document_date__gte=year_start).count() + 1,
            number_total=self.__class__.objects.all().count() + 1,
        )
        return number

    def __str__(self):
        return f'{self.document_number} at {self.document_date}'

    class Meta:
        abstract = True


class Actor(CodeNaturalKeyAbstractModel):
    """An actor in economical relations."""
    name = models.CharField(max_length=200, blank=True)

    def __str__(self):
        return f'{self.name}'

    def create_account(self, currency, account_name='default', description=None) -> 'Account':
        assert currency
        return Account.objects.create(
            name=account_name,
            owner=self,
            currency=currency,
            description=description,
        )

    def get_account(self, currency, account_name='default') -> 'Account':
        return self.accounts.filter(
            name=account_name,
            currency=currency
        ).first()

    def get_or_create_account(self, currency, account_name='default', description=None) -> 'Account':
        account = self.get_account(currency, account_name)
        if account:
            return account
        else:
            return self.create_account(currency, account_name, description)


class Organization(Actor):
    website = models.URLField(null=True, blank=True)


class Person(CreatedUpdatedMixin, Actor):
    first_name = models.CharField(max_length=100, blank=True)
    last_name = models.CharField(max_length=150, blank=True)
    email = models.EmailField(null=True, unique=True)  # TODO: can we use unique=True for nullable ?
    phone = models.CharField(max_length=20, default='', blank=True)
    skype = models.CharField(max_length=100, default='', blank=True)
    google_account = models.CharField(max_length=200, default='', blank=True)
    github_account = models.CharField(max_length=200, default='', blank=True)
    avatar_url = models.URLField(null=True, blank=True)
    language = models.CharField(max_length=10, choices=settings.LANGUAGES, default='ru')
    country = models.CharField(max_length=100, default='', blank=True)
    city = models.CharField(max_length=100, default='', blank=True)
    timezone = models.CharField(max_length=100, choices=[(tz, tz) for tz in pytz.all_timezones],
                                default=settings.TIME_ZONE)
    birth_date = models.DateField(null=True, blank=True, verbose_name=_('Birth date'))
    user = models.OneToOneField(User, null=True, blank=True, on_delete=models.SET_NULL, related_name='person')
    is_admin = models.BooleanField(default=False)
    can_teach = models.BooleanField(default=False)

    @property
    def full_name(self):
        return self.name

    @classmethod
    def _guess_first_and_last_name(cls, name: str):
        names = iter(name.split(maxsplit=1) if name else [])
        first_name = next(names, '')
        last_name = next(names, '')
        return first_name.strip(), last_name.strip()

    @full_name.setter
    def full_name(self, value):
        self.name = value

    def __str__(self):
        return f'{self.full_name} {self.email}'

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        if self.name and not (self.first_name and self.last_name):
            self.first_name, self.last_name = self._guess_first_and_last_name(self.name)
        elif (self.first_name or self.last_name) and not self.name:
            # filter out empty names
            names = [name for name in (self.first_name, self.last_name) if name]
            self.name = ' '.join(names)
        super().save(force_insert, force_update, using, update_fields)

    @classmethod
    def lookup_by_email(cls, email):
        return cls.objects.filter(email__iexact=email).first()


class Product(CreatedUpdatedMixin, CodeNaturalKeyAbstractModel):
    class State(TextChoices):
        DRAFT = 'DRAFT', 'Черновик'
        ACTIVE = 'ACTIVE', 'Активен'
        ARCHIVED = 'ARCHIVED', 'Архивирован'

    price = MoneyField(max_digits=14, decimal_places=2)
    name = models.CharField(max_length=250)
    state = models.CharField(max_length=8, choices=State.choices, null=True, blank=True)


class PhysicalProduct(Product):
    """The product physically existing. Has weight and volume."""
    pass


class VirtualProduct(Product):
    """non-physical product. It can be digital product of service."""
    pass


class Order(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'CO-{number_month}'

    class State(TextChoices):
        NEW = 'NEW', "Новый"
        WAITING = 'WAITING', "Ожидает"
        CONFIRMED = 'CONFIRMED', "Подтверждён"
        COMPLETED = 'COMPLETED', "Выполнен"
        PROCESSING = 'PROCESSING', "Исполняется"
        CANCELLED = 'CANCELLED', "Отменён"

    FINAL_STATES = (State.COMPLETED, State.CANCELLED)

    class FulfillOn(TextChoices):
        CREATED = 'CREATED', "когда заказ создан"
        CONFIRMED = 'CONFIRMED', "когда заказ подтверждён"
        ORDER_PAYED_FULL = 'ORDER_PAYED_FULL', "когда счет оплачен полностью"
        ORDER_PAYED_PARTLY = 'ORDER_PAYED_PARTLY', "когда счет оплачен частично"

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)
    seller = models.ForeignKey(Actor, on_delete=models.CASCADE, null=True, blank=True, related_name='+')
    buyer = models.ForeignKey(Actor, on_delete=models.CASCADE, null=True, blank=True, related_name='+')
    currency = CurrencyField()
    valid_until = models.DateField(null=True, blank=True)

    comment = models.TextField(null=True, blank=True)
    fulfill_on = models.CharField(max_length=200, choices=FulfillOn.choices, null=True, blank=True)

    @property
    def amount(self):
        currency = self.currency
        if not currency:
            raise ValueError(f'No currency in order {self}')
        return reduce(lambda x, item: x + item.sum, self.items.all(), Money(0, currency))

    def add_item(self, product: Product, quantity: int = 1):
        OrderItem.objects.create(
            product=product,
            order=self,
            price=product.price,
            quantity=quantity
        )

    def create_invoice(self) -> 'Invoice':
        return Invoice(
            order=self,
            amount=self.amount,
            seller=self.seller,
            buyer=self.buyer,
        )

    def fulfill(self):
        states = Order.State
        assert self.state in (None, states.NEW, states.CONFIRMED), f"Cannot fulfill from state {self.state}"
        self.set_state(states.PROCESSING)


class OrderItem(OrderingMixin, models.Model):
    product = models.ForeignKey(Product, on_delete=models.SET_NULL, null=True)
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')
    price = MoneyField(max_digits=14, decimal_places=2)
    quantity = models.DecimalField(default=1, max_digits=14, decimal_places=0)

    @property
    def sum(self):
        return self.price * self.quantity

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        if not self.ordering:
            self.ordering = self.__class__.objects.filter(order=self.order).count() + 1
        super().save(force_insert, force_update, using, update_fields)


class Invoice(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'I-{number_month}'

    class State(TextChoices):
        NEW = 'NEW', 'Новый'
        WAITING = 'WAITING', 'Ожидает'
        PAYED_PARTLY = 'PAYED_PARTLY', 'Частично оплачен'
        PAYED_FULLY = 'PAYED_FULLY', 'Полностью оплачен'
        CANCELLED = 'CANCELLED', 'Отменен'

    seller = models.ForeignKey(Actor, on_delete=models.CASCADE, null=True, blank=True, related_name='+')
    seller_account = models.ForeignKey('Account', on_delete=models.CASCADE, null=True, blank=True, related_name='+')
    buyer = models.ForeignKey(Actor, on_delete=models.CASCADE, null=True, blank=True, related_name='+')
    buyer_account = models.ForeignKey('Account', on_delete=models.CASCADE, null=True, blank=True, related_name='+')
    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)

    order = models.ForeignKey(Order, on_delete=models.PROTECT, null=True, blank=True)
    valid_until = models.DateField(null=True, blank=True)
    amount = MoneyField(max_digits=14, decimal_places=2)

    @property
    def payed_amount(self):
        return reduce(
            lambda x, payment: x + payment.amount,
            self.payments.filter(invoice=self, state=Payment.State.PROCESSED),
            Money(0, self.amount.currency))

    @property
    def is_payed(self):
        return self.payed_amount >= self.amount

    def create_payment(self) -> 'Payment':
        return Payment(
            invoice=self,
            amount=self.amount,
            sender_account=self.buyer_account,
            receiver_account=self.seller_account,
        )


class Account(CodeNaturalKeyAbstractModel):
    name = models.CharField(max_length=100, null=True, blank=True)
    owner = models.ForeignKey(Actor, on_delete=models.CASCADE, related_name='accounts')
    currency = CurrencyField()
    description = models.CharField(max_length=200, null=True, blank=True)

    def __str__(self):
        return f'{self.name} ({self.currency}) of {self.owner}'

    def balance(self):
        return reduce(lambda x, item: x + item.amount, self.payments_in.all(), Money(0, self.currency)) \
               - reduce(lambda x, item: x + item.amount, self.payments_out.all(), Money(0, self.currency))



class Payment(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'MT-{number_year}'

    class State(TextChoices):
        NEW = 'NEW', 'создан'
        WAITING = 'WAITING', 'в ожидании'
        IN_PROCESS = 'IN_PROCESS', 'в процессе'
        PROCESSED = 'PROCESSED', 'произведен'
        CANCELLED = 'CANCELLED', 'отменён'

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)

    sender_account = models.ForeignKey(Account, on_delete=models.PROTECT, related_name='payments_out')
    receiver_account = models.ForeignKey(Account, on_delete=models.PROTECT, related_name='payments_in')
    amount = MoneyField(max_digits=14, decimal_places=2)
    description = models.TextField(max_length=2000, null=True, blank=True)

    invoice = models.ForeignKey(Invoice, on_delete=models.PROTECT, null=True, blank=True, related_name='payments')
    completed_at = models.DateTimeField(null=True, blank=True)

    provider = models.CharField(max_length=200, null=True, blank=True, help_text=_('Who provide this money transfer'))
    # TODO: move out these specific things
    payment_gateway = models.CharField(max_length=255, null=True, blank=True, help_text="Payment gateway")
    gateway_payment_id = models.CharField(max_length=255, null=True, blank=True, help_text="Payment ID in the gateway")
    gateway_payment_url = models.URLField(null=True, blank=True, help_text="URL to pay this payment")

    def __str__(self):
        return f'#{self.id} {self.amount} ({self.state})'

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        currency = self.amount.currency.code
        if self.sender_account:
            account = self.sender_account
            account_currency = account.currency
            if account_currency != currency:
                raise ValueError(f'Cannot move {currency} from {account_currency} account {account.code}')
        if self.receiver_account:
            account = self.receiver_account
            account_currency = account.currency
            if account_currency != currency:
                raise ValueError(f'Cannot move {currency} to {account_currency} account {account.code}')
        super().save(force_insert, force_update, using, update_fields)

    def is_completed(self):
        return self.state == self.State.PROCESSED


class ShipmentItem(models.Model):
    shipment = models.ForeignKey('Shipment', on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.DecimalField(default=1, max_digits=14, decimal_places=2)


class Shipment(Document):
    DOCUMENT_NUMBER_TEMPLATE = 'S-{number_year}'

    sender = models.ForeignKey(Actor, on_delete=models.PROTECT, related_name='+')
    receiver = models.ForeignKey(Actor, on_delete=models.PROTECT, related_name='+')
    order = models.ForeignKey(Order, on_delete=models.CASCADE, null=True, blank=True)
    items = models.ManyToManyField(Product, through=ShipmentItem)
    description = models.CharField(max_length=255, null=True, blank=True)

    def add_item(self, product: Product, quantity: int):
        item = ShipmentItem(product=product, shipment=self, quantity=quantity)
        item.save()
        self.shipmentitem_set.add(item)

    @staticmethod
    def from_order(order: Order):
        shipment = Shipment(order=order, receiver=order.buyer, sender=order.seller)
        for item in order.items.all():
            shipment.add_item(item.product, item.quantity)
        return shipment


class Employee(StatefulMixin, models.Model):
    class State(TextChoices):
        ACTIVE = 'ACTIVE', 'действующий'
        DISMISSED = 'DISMISSED', 'уволенный'

    state = models.CharField(max_length=200, choices=State.choices, null=True, blank=True)

    person = models.ForeignKey(Person, on_delete=models.PROTECT)
    organization = models.ForeignKey(Organization, on_delete=models.CASCADE)
    position = models.CharField(max_length=100, null=True, blank=True)
